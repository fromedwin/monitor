{% comment %}
  Reusable Loading Overlay Component
  
  Usage:
  {% include 'components/loading_overlay.html' with 
    project_id=project.id 
    title="Scanning your website..." 
    description="We're analyzing your website to gather performance data"
    tasks="favicon,sitemap,scraping,lighthouse,prometheus"
  %}
  
  Parameters:
  - project_id: The project ID for API calls
  - title: Main title for the loading overlay
  - description: Description text below the title
  - tasks: Comma-separated list of task names to monitor
{% endcomment %}
<!-- Loading Overlay -->
<div id="loading-overlay"
     class="hidden bg-white bg-opacity-90 z-10 flex items-center justify-center mb-6 rounded-lg border border-gray-200">
    <div class="bg-white rounded-lg shadow-xl p-8 max-w-md w-full mx-4">
        <div class="text-center mb-6">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-emerald-600 mx-auto mb-4"></div>
            <h3 class="text-lg font-semibold text-gray-900 mb-2">{{ title|default:"Loading..." }}</h3>
            <p class="text-sm text-gray-600">{{ description|default:"Please wait while we process your request" }}</p>
        </div>
        <div class="space-y-4" id="tasks-container">
            <!-- Tasks will be dynamically generated here -->
        </div>
        <!-- Completion Message -->
        <div id="completion-message"
             class="hidden mt-6 p-4 bg-green-50 border border-green-200 rounded-lg">
            <div class="flex items-center">
                <svg class="w-5 h-5 text-green-600 mr-2"
                     fill="none"
                     stroke="currentColor"
                     viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                </svg>
                <span class="text-sm font-medium text-green-800">All tasks completed! Your analysis is ready.</span>
            </div>
        </div>
    </div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
  // Loading overlay functionality
  const projectId = {{ project_id }};
  const loadingOverlay = document.getElementById('loading-overlay');
  const completionMessage = document.getElementById('completion-message');
  
  // Initialize progress bars and status texts
  const progressBars = {};
  const statusTexts = {};
  const tasks = '{{ tasks }}'.split(',');
  
  // Dynamically generate task elements
  const tasksContainer = document.getElementById('tasks-container');
  tasks.forEach(task => {
    const taskDiv = document.createElement('div');
    taskDiv.innerHTML = `
      <div class="flex justify-between items-center mb-2">
        <span class="text-sm font-medium text-gray-700">${task.charAt(0).toUpperCase() + task.slice(1)} Loading</span>
        <span id="${task}-status" class="text-sm text-gray-600">⏳ Waiting...</span>
      </div>
      <div class="w-full bg-gray-200 rounded-full h-2">
        <div id="${task}-progress" class="h-2 bg-gray-300 rounded-full transition-all duration-500 w-0"></div>
      </div>
    `;
    tasksContainer.appendChild(taskDiv);
    
    // Store references to the elements
    progressBars[task] = document.getElementById(`${task}-progress`);
    statusTexts[task] = document.getElementById(`${task}-status`);
  });
  
  let checkInterval;
  
  function updateProgressBar(task, status, progress = null) {
    const progressBar = progressBars[task];
    const statusText = statusTexts[task];
    
    if (!progressBar || !statusText) return;
    
    if (status === 'SUCCESS') {
      progressBar.className = 'h-2 bg-green-500 rounded-full transition-all duration-500';
      progressBar.style.width = '100%';
      statusText.textContent = '✓ Completed';
      statusText.className = 'text-sm text-green-600 font-medium';
    } else if (status === 'PENDING') {
      if (progress && progress.total > 0) {
        const percentage = Math.round((progress.completed / progress.total) * 100);
        progressBar.className = 'h-2 bg-blue-500 rounded-full transition-all duration-500';
        progressBar.style.width = percentage + '%';
        statusText.textContent = `⟳ Processing... (${progress.completed}/${progress.total})`;
      } else {
        progressBar.className = 'h-2 bg-blue-500 rounded-full transition-all duration-500 animate-pulse';
        progressBar.style.width = '50%';
        statusText.textContent = '⟳ Processing...';
      }
      statusText.className = 'text-sm text-blue-600 font-medium';
    } else if (status === 'FAILURE') {
      progressBar.className = 'h-2 bg-red-500 rounded-full transition-all duration-500';
      progressBar.style.width = '100%';
      statusText.textContent = '✗ Failed';
      statusText.className = 'text-sm text-red-600 font-medium';
    } else if (status === 'UNKNOWN') {
      progressBar.className = 'h-2 bg-gray-300 rounded-full transition-all duration-500';
      progressBar.style.width = '0%';
      statusText.textContent = '❓ Unknown';
      statusText.className = 'text-sm text-gray-600 font-medium';
    } else {
      progressBar.className = 'h-2 bg-gray-300 rounded-full transition-all duration-500';
      progressBar.style.width = '0%';
      statusText.textContent = '⏳ Waiting...';
      statusText.className = 'text-sm text-gray-600 font-medium';
    }
  }
  
  function checkTaskStatus() {
    fetch(`/api/project/${projectId}/task_status/`)
      .then(response => response.json())
      .then(data => {
        // Update each task's progress
        tasks.forEach(task => {
          const statusKey = `${task}_status`;
          const progressKey = `${task}_progress`;
          updateProgressBar(task, data[statusKey], data[progressKey]);
        });
        
        // Check if any task is still pending 
        const hasPendingTasks = !data.all_complete;
        
        // Show overlay if there are pending tasks, hide if all complete
        if (hasPendingTasks) {
          loadingOverlay.classList.remove('hidden');
        } else {
          loadingOverlay.classList.add('hidden');
        }
        
        if (data.all_complete) {
          clearInterval(checkInterval);
          completionMessage.style.display = 'block';
          setTimeout(() => {
            loadingOverlay.style.display = 'none';
            // If loadingOverlay is visible, reload the page
            if (!loadingOverlay.classList.contains('hidden')) {
              window.location.reload();
            }
          }, 2000);
          return;
        }
      })
      .catch(error => {
        console.error('Error checking task status:', error);
      });
  }
  
  // Start checking every 2 seconds (first call will be immediate)
  checkInterval = setInterval(checkTaskStatus, 2000);
  checkTaskStatus();
});
</script>
